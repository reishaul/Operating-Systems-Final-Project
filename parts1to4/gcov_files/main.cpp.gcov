        -:    0:Source:main.cpp
        -:    0:Graph:main.gcno
        -:    0:Data:main.gcda
        -:    0:Runs:10
        -:    1://Rei Shaul E-mail: reishaul1@gmail.com
        -:    2:#include <iostream>
        -:    3:#include <vector>
        -:    4:#include <iostream>
        -:    5:#include <random>
        -:    6:#include <ctime>
        -:    7:#include <unistd.h>  // For getopt  
        -:    8:#include "graph.hpp"
        -:    9:
       10:   10:int main(int argc, char* argv[]) {
       10:   11:    int num_vertices = 0;
       10:   12:    int num_edges = 0;
       10:   13:    int seed =time(nullptr); // Seed the random number generator with the current time
        -:   14:
        -:   15:    int opt;
       33:   16:    while ((opt = getopt(argc, argv, "v:e:s:")) != -1) {
       26:   17:        switch (opt) {
        9:   18:            case 'v':
        9:   19:                num_vertices = std::stoi(optarg);
        9:   20:                break;
        7:   21:            case 'e':
        7:   22:                num_edges = std::stoi(optarg);
        7:   23:                break;
        7:   24:            case 's':
        7:   25:                seed = std::stoi(optarg);
        7:   26:                break;
        3:   27:            default:
        3:   28:                std::cerr << "Usage: " << argv[0] << " -v <num_vertices> -e <num_edges> -s <seed>\n";
        3:   29:                return 1;
        -:   30:        }
        -:   31:    }
        -:   32:
        7:   33:    if(num_vertices <= 0 || num_edges < 0) {
        3:   34:        std::cerr << "Invalid number of vertices or edges.\n";
        3:   35:        return 1;
        -:   36:    }
        8:   37:    graph::Graph gr(num_vertices);
        4:   38:    std::mt19937 rng(seed); // Initialize random number generator with the seed
        4:   39:    std::uniform_int_distribution<int> dist(0, num_vertices - 1);
        -:   40:
       29:   41:    for (int i=0; i<num_edges; ++i) {
       25:   42:        int u = dist(rng);
       25:   43:        int v = dist(rng);
        -:   44:
       25:   45:        if(u==v){
       12:   46:            --i; // prevent self-loops
       15:   47:            continue; // Skip this iteration if self-loop is generated
        -:   48:        }
        -:   49:        
        -:   50:        // Check if edge already exists
       13:   51:        bool edgeExists = false;
       13:   52:        auto edges = gr.get_edges();
       26:   53:        for(const auto& edge : edges) {
       30:   54:            if((std::get<0>(edge) == u && std::get<1>(edge) == v) ||
       14:   55:               (std::get<0>(edge) == v && std::get<1>(edge) == u)) {
        3:   56:                edgeExists = true;
        3:   57:                break;
        -:   58:            }
        -:   59:        }
        -:   60:        
       13:   61:        if(edgeExists){
        3:   62:            --i; // prevent duplicate edges
        3:   63:            continue; // Skip this iteration if the edge already exists
        -:   64:        }
       10:   65:        gr.addEdge(u, v);
        -:   66:        
       13:   67:    }
        4:   68:    std::cout << "Graph with " << num_vertices << " vertices and " << num_edges << " edges created\n";
        -:   69:
        4:   70:    gr.print_graph();
        8:   71:    auto ecircuit = gr.get_eulerian_cycle();
        4:   72:    if (ecircuit.empty()) {
    #####:   73:        std::cout << "No Eulerian circuit found\n";
        -:   74:    } 
        -:   75:    else {
        4:   76:        std::cout << "Eulerian circuit found: ";
       18:   77:        for (int v : ecircuit) {
       14:   78:            std::cout << v << " ";
        -:   79:        }
        4:   80:        std::cout << "\n";
        -:   81:    }
        -:   82:
        4:   83:    std::cout << "some changes in the graph:\n";
        -:   84:    // Test removeEdge functionality
        4:   85:    if (num_edges > 0) {
        3:   86:        auto edges = gr.get_edges();
        3:   87:        if (!edges.empty()) {
        3:   88:            auto first_edge = edges[0];
        3:   89:            int src = std::get<0>(first_edge);
        3:   90:            int dest = std::get<1>(first_edge);
        3:   91:            std::cout << "Removing edge (" << src << ", " << dest << ")\n";
        3:   92:            gr.removeEdge(src, dest);
        3:   93:            std::cout << "Edge removed successfully.\n";
        -:   94:            
        -:   95:            // Try to remove non-existent edge to test exception
        -:   96:            try {
        3:   97:                gr.removeEdge(src, dest); // This should throw an exception
        3:   98:            } catch (const std::runtime_error& e) {
        3:   99:                std::cout << "Expected error caught: " << e.what() << "\n";
        3:  100:            }
        -:  101:        }
        3:  102:    }
        -:  103:
        -:  104:    // Test invalid constructor
        -:  105:    try {
        4:  106:        graph::Graph invalid_graph(-1);
       4*:  107:    } catch (const std::invalid_argument& e) {
        4:  108:        std::cout << "Expected error caught: " << e.what() << "\n";
        4:  109:    }
        -:  110:
        -:  111:    // Test invalid vertex access
        -:  112:    try {
        4:  113:        gr.addEdge(-1, 0); // This should throw out_of_range
        4:  114:    } catch (const std::out_of_range& e) {
        4:  115:        std::cout << "Expected error caught: " << e.what() << "\n";
        4:  116:    }
        -:  117:
        -:  118:    // Create a disconnected graph to test isConnected
        4:  119:    graph::Graph disconnected_graph(5);
        4:  120:    disconnected_graph.addEdge(0, 1);
        4:  121:    disconnected_graph.addEdge(2, 3);
        -:  122:    // vertex 4 is isolated, vertices 0-1 and 2-3 are in separate components
        -:  123:    try {
        4:  124:        auto circuit = disconnected_graph.get_eulerian_cycle();
       4*:  125:    } catch (const std::runtime_error& e) {
        4:  126:        std::cout << "Expected error for disconnected graph: " << e.what() << "\n";
        4:  127:    }
        -:  128:
        -:  129:    // Test get_eulerian_cycle with graph that doesn't have Eulerian cycle
        -:  130:    try {
        4:  131:        auto ecircuit = gr.get_eulerian_cycle();
        1:  132:        if (ecircuit.empty()) {
    #####:  133:            std::cout << "No Eulerian circuit found\n";
        -:  134:        }
        -:  135:        else {
        -:  136:            
        1:  137:            std::cout << "Eulerian circuit found: ";
        2:  138:            for (int v : ecircuit) {
        1:  139:                std::cout << v << " ";
        -:  140:            }
        1:  141:            std::cout << "\n";
        -:  142:        }
        4:  143:    } catch (const std::runtime_error& e) {
        3:  144:        std::cout << "Expected error caught: " << e.what() << "\n";
        3:  145:    }
        -:  146:
        4:  147:    return 0;
        -:  148:}
