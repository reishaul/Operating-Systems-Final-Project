        -:    0:Source:graph.cpp
        -:    0:Graph:graph.gcno
        -:    0:Data:graph.gcda
        -:    0:Runs:10
        -:    0:Source is newer than graph
        -:    1:// reishaul1@gmail.com
        -:    2:/** 
        -:    3: The Graph class represents an undirected graph using an adjacency list.
        -:    4: It provides methods to add and remove edges, print the graph, and retrieve
        -:    5: graph-related information such as the number of vertices and edges.
        -:    6:*/
        -:    7:#include "graph.hpp"
        -:    8:// #include "Algorithms/MST.hpp" // Include the MST algorithm for minimum spanning tree functionality  
        -:    9:// #include "Algorithms/MaxFlow.hpp" // Include the MaxFlow algorithm
        -:   10:#include <stack>
        -:   11:#include <algorithm>
        -:   12:
        -:   13:
        -:   14:namespace graph {
        -:   15:
        -:   16:/**
        -:   17: * @brief Constructs a graph with the given number of vertices.
        -:   18: * @param num_ver The number of vertices in the graph.
        -:   19: * @throws std::invalid_argument if the number of vertices is invalid.
        -:   20: */
       12:   21:Graph::Graph(int num_ver) : num_of_vertex(num_ver) {
       12:   22:    if ( num_ver <= 0) {
        4:   23:        throw std::invalid_argument("Invalid number of vertex");
        -:   24:    }
        8:   25:    adj_list.resize(num_ver);
       12:   26:}
        -:   27:
        -:   28:/**
        -:   29: * @brief Adds an edge between two vertices with a specified weight.
        -:   30: * @param src Source vertex.
        -:   31: * @param dest Destination vertex
        -:   32: * @param w Weight of the edge
        -:   33: */
       22:   34:void Graph::addEdge(int src, int dest, int w) {
       22:   35:    validVertex(src);
       18:   36:    validVertex(dest);
        -:   37:
       18:   38:    // Check if edge already exists
       18:   39:    // for (const auto& edge : adj_list[src]) {
       18:   40:    //     if (edge.dest == dest) {
        -:   41:    //         return; // Edge already exists, don't add duplicate
        -:   42:    //     }
       18:   43:    // }
        -:   44:
        -:   45:    adj_list[src].push_back({dest, w});
        -:   46:    if (src != dest) {
        -:   47:        adj_list[dest].push_back({src, w});
        -:   48:    }
        -:   49:    //edges.push_back({src, dest, w});
        -:   50:}
        6:   51:
        6:   52:/**
        6:   53: * @brief Removes an edge between two vertices.
        6:   54: * @param src Source vertex
        6:   55: * @param dest Destination vertex
        3:   56: * @throws runtime_error if the edge does not exist.
        -:   57: */
        3:   58:void Graph::removeEdge(int src, int dest) {
       3*:   59:    validVertex(src);
        -:   60:    validVertex(dest);
        3:   61:    bool removed = removeNeighborEdge(src, dest);
        -:   62:    if(!removed) {
        -:   63:        throw std::runtime_error("Edge not found in the graph");
        -:   64:    }
        -:   65:    if ( src != dest) {
        -:   66:        removed = removeNeighborEdge(dest, src)||removed;
        4:   67:    }
       18:   68:}
       14:   69:
       34:   70:
       20:   71:/**
        -:   72: * @brief Prints the adjacency list representation of the graph
       14:   73: */
        -:   74:void Graph::print_graph() {//printing the graph in a logical way
        4:   75:    for (int i = 0; i < num_of_vertex; i++) {
        -:   76:        std::cout << "Node " << i << ": ";
        -:   77:        for(const auto& edge : adj_list[i]) {
        -:   78:            std::cout << "(" << edge.dest << ", weight: " << edge.weight << ") ";
        -:   79:        }
        -:   80:        std::cout << std::endl;
        -:   81:    }
        -:   82:}
        -:   83:
        -:   84:/**
        -:   85: * @brief Returns the number of vertices in the graph.
        -:   86: * @return The number of vertices.
        -:   87: */
        -:   88:// int Graph::get_num_of_vertex() const{
        -:   89://     return num_of_vertex;
       16:   90:// }
       16:   91:
        -:   92:/**
       69:   93: * @brief Retrieves all edges in the graph.
      109:   94: * @param numEdges Reference to store the number of edges found.
       56:   95: * @return A dynamically allocated array of edges.
       28:   96: */
        -:   97:std::vector<std::tuple<int,int,int>> Graph::get_edges() const {
        -:   98:    std::vector<std::tuple<int,int,int>> edges;
        -:   99:
       16:  100:    for (int i = 0; i < num_of_vertex; ++i) {
    =====:  101:        for(const auto& edge : adj_list[i]) {
        -:  102:            if(i < edge.dest) { // to avoid duplicates in undirected graphs
      123:  103:                edges.emplace_back(i, edge.dest, edge.weight);
      123:  104:            }
        4:  105:        }
      119:  106:    }
        -:  107:    return edges;
        -:  108:}
        -:  109:
        -:  110:void Graph::validVertex(int v) const {
        -:  111:    if (v < 0 || v >= num_of_vertex)
        -:  112:        throw std::out_of_range("Vertex index out of range");
        -:  113:}
        -:  114:
        -:  115:
        9:  116:/**
        9:  117: * @brief Removes an edge from the adjacency list.
       13:  118: * for undirected graphs, it removes the edge in both directions.
       10:  119: * @param src Source vertex
        6:  120: * @param dest Destination vertex
        6:  121: * @return true if the edge was removed, false if it was not found.
        -:  122: */
        -:  123:bool Graph::removeNeighborEdge(int src, int dest) {
        3:  124:    auto& edges = adj_list[src];
        -:  125:    for (auto it = edges.begin(); it != edges.end(); ++it) {
        -:  126:        if (it->dest == dest) {
        -:  127:            edges.erase(it);
        -:  128:            return true;
        -:  129:        }
        -:  130:    }
        -:  131:    return false;
        -:  132:}
       71:  133:
       71:  134:/**
       71:  135: * @brief Returns the degree of a vertex.
        -:  136: * @param v Vertex index
        -:  137: * @return The degree of the vertex.
        -:  138: * @throws std::out_of_range if the vertex index is invalid.
        -:  139: */
        -:  140:int Graph::degree(int v) const {
        -:  141:    validVertex(v);
        -:  142:    return static_cast<int>(adj_list[v].size());
       12:  143:}
       12:  144:
       20:  145:
       18:  146:/**
       10:  147: * @brief Checks if the graph is connected ignoring isolated vertices.
       10:  148: * @return true if the graph is connected, false otherwise.
        -:  149: */
        -:  150:bool Graph::isConnected() const {
       12:  151:    int a=-1;
        -:  152:    for (int i = 0; i < num_of_vertex; ++i) {
       10:  153:        if (degree(i) > 0) {
       10:  154:            a = i;
        -:  155:            break;
       10:  156:        }
       10:  157:    }
        -:  158:    if (a == -1) return true; // If there is no any edges, the graph is trivially connected
        -:  159:
        -:  160:    std::vector<bool> visited(num_of_vertex, false);
       38:  161:    std::stack<int> stack;
       28:  162:
       28:  163:    stack.push(a);
        -:  164:    visited[a] = true;
       70:  165:
       42:  166:    // Perform DFS to check connectivity
       18:  167:    // We use a stack to avoid recursion depth issues in large graphs
       18:  168:    while (!stack.empty()) {
        -:  169:        int v = stack.top();
        -:  170:        stack.pop();
        -:  171:
        -:  172:        for (const auto& edge : adj_list[v]) {
       38:  173:            if (!visited[edge.dest]) {
       32:  174:                visited[edge.dest] = true;
        4:  175:                stack.push(edge.dest);
        -:  176:            }
        -:  177:        }
        6:  178:    }
       10:  179:
        -:  180:    for(int i = 0; i < num_of_vertex; ++i) {
        -:  181:        if (degree(i) > 0 && !visited[i]) {
        -:  182:            return false; // Found a vertex with edges that is not visited
        -:  183:        }
        -:  184:    }
        -:  185:    return true; // All vertices with edges are connected
       12:  186:}
       12:  187:
        -:  188:/**
       26:  189: * @brief Checks if the graph has an Eulerian cycle.
       21:  190: * An Eulerian cycle exists if the graph is connected and all vertices have even degree.
        3:  191: * @return true if the graph has an Eulerian cycle, false otherwise.
        -:  192: */
        -:  193:bool Graph::has_eulerian_cycle() const {
        5:  194:    if (!isConnected()) return false;
        -:  195:
        -:  196:    for (int v = 0; v < num_of_vertex; ++v) {
        -:  197:        if (degree(v) % 2 != 0) {
        -:  198:            return false; // Vertex with odd degree found
        -:  199:        }
        -:  200:    }
        -:  201:    return true; // All vertices have even degree
        -:  202:}
       12:  203:
        -:  204:/**
       12:  205: * @brief Finds an Eulerian cycle in the graph if it exists.
        7:  206: * Uses Hierholzer's algorithm to find the cycle.
        -:  207: * @return A vector containing the vertices in the Eulerian cycle.
        5:  208: * @throws std::runtime_error if no Eulerian cycle exists.
        5:  209: */
        -:  210:std::vector<int> Graph::get_eulerian_cycle() const {
       23:  211:
       18:  212:    if (!has_eulerian_cycle())// Check if the graph has an Eulerian cycle
       18:  213:        throw std::runtime_error("Eulerian circuit does not exist");
        -:  214:
        9:  215:    int a = -1;
        -:  216:    long long totalHalfEdges = 0;// Count total half-edges to find a starting point
        -:  217:    // Find a starting vertex with edges
        -:  218:    for (int v = 0; v < num_of_vertex; ++v) {
        -:  219:        if (!adj_list[v].empty() && a == -1) a = v;
        -:  220:        totalHalfEdges += adj_list[v].size();
        -:  221:    }
        -:  222:    if (a == -1) return {0}; // single isolated vertex circuit
        -:  223:
        3:  224:    // Build an auxiliary adjacency with edge IDs to mark edges as used once.
        3:  225:    // Each undirected edge gets one id and appears once in each endpoint list
       13:  226:    struct Next {
       30:  227:        int dest;
       20:  228:        int id;
       10:  229:    };
       10:  230:
       10:  231:    std::vector<std::vector<Next>> graph(num_of_vertex);
        -:  232:    int k = 0;
        -:  233:    for (int u = 0; u < num_of_vertex; ++u) {
        -:  234:        for (const auto& edge : adj_list[u]) {
        3:  235:            if (u <= edge.dest) { // assign id only once per undirected edge (handles parallel edges too)
        -:  236:                int id = k++;
        -:  237:                graph[u].push_back({edge.dest, id});
        3:  238:                graph[edge.dest].push_back({u, id});
        3:  239:            }
        3:  240:        }
        -:  241:    }
        -:  242:    std::vector<char> used(k, false);
       26:  243:
       23:  244:    // Hierholzer's algorithm from the starting vertex 
       23:  245:    std::vector<int> circuit;
        -:  246:    std::stack<int> stck;
        -:  247:    stck.push(a);
       33:  248:
        -:  249:    // For efficiency, we'll lazily skip used edges by popping from the back until we find an unused one.
        -:  250:    while (!stck.empty()) {
       23:  251:        int v = stck.top();
       10:  252:        auto &lst = graph[v];// Get the list of edges for the current vertex
       10:  253:
       10:  254:        // Remove already-used edges from the tail(end) of the list
       10:  255:        while (!lst.empty() && used[lst.back().id]) lst.pop_back();
       10:  256:
        -:  257:        // If there are still edges left, take the last one
        -:  258:        if (!lst.empty()) {
        -:  259:            auto e = lst.back();
       13:  260:            lst.pop_back();
       13:  261:            if (!used[e.id]) {
        -:  262:                used[e.id] = true;
        -:  263:                stck.push(e.dest);
        -:  264:            }
        3:  265:        } else {
        3:  266:            // dead end -> add to circuit and backtrack
        3:  267:            circuit.push_back(v);//adding the last vertex to complete the circuit
        -:  268:            stck.pop();
        -:  269:        }
        -:  270:    }
        -:  271:
        -:  272:    std::reverse(circuit.begin(), circuit.end());// Hierholzer constructs the circuit in reverse order so we need to reverse the circuit to get the correct order
        -:  273:    return circuit;
        -:  274:}
        -:  275:
        -:  276://for the algserver 
        -:  277:
        -:  278://function to find the minimum spanning tree weight
        -:  279:// long long Graph::mst_weight() const {
        -:  280://     return mst_weight_kruskal(*this);
        -:  281:// }
        -:  282:
        -:  283:// int Graph::max_flow(int a, int b) const {
        -:  284://     int n = num_of_vertex;
        -:  285://     MaxFlow mf(n);
        -:  286:
        -:  287://     // Initialize the MaxFlow object with the graph's edges
        -:  288://     for (int u = 0; u < n; ++u) {
        -:  289://         for (auto &e : adj_list[u]) {
        -:  290://             mf.addEdge(u, e.dest, e.weight);
        -:  291://         }
        -:  292://     }
        -:  293://     return mf.getMaxFlow(a, b);
        -:  294:// }
        -:  295:
        -:  296:/**
        -:  297: * @brief Returns the neighbors of a vertex.
        -:  298: * @param v Vertex index
        -:  299: * @return A reference to the adjacency list of the vertex.
        -:  300: * @throws std::out_of_range if the vertex index is invalid.
        -:  301: */
        -:  302:// const std::vector<Graph::Edge>& Graph::neighbors(int v) const {
        -:  303://     validVertex(v);
        -:  304://     return adj_list[v];
        -:  305:// }
        -:  306:  
        -:  307:} // namespace graph
